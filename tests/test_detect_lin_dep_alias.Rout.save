
R version 3.5.2 (2018-12-20) -- "Eggshell Igloo"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # Tests for functions:
> #  * detect.lindep
> #  * alias
> # YC 2017/10/09 :  RE model par defaut pb because the between model is empty
> 
> 
> library(plm)
> data("Cigar", package = "plm")
> Cigar[ , "fact1"] <- c(0,1)
> Cigar[ , "fact2"] <- c(1,0)
> Cigar.p <- pdata.frame(Cigar)
> 
> #pform <- pFormula(price ~ 0 + cpi + fact1 + fact2)
> form <- price ~ 0 + cpi + fact1 + fact2
> mf <- model.frame(Cigar.p, form)
> 
> # for the pooling model.matrix, there is no linear dependence
> # (because the intercept is left out in this case in the formula)
> #MM detect.lindep(model.matrix(pform, data = Cigar.p, model = "pooling"))
> 
> detect.lindep(model.matrix(mf, model = "pooling"))
[1] "No linear dependent column(s) detected."
> 
> ## check if backward compatibility works
> detect_lin_dep(model.matrix(mf, model = "pooling"))
[1] "No linear dependent column(s) detected."
Warning message:
Function name 'detect_lin_dep' deprecated, please use 'detect.lindep' 
> 
> # linear dependence occury after FE transformation
> # [after transformation fact1 == -1 * fact2]
> #MM detect.lindep(model.matrix(pform, data = Cigar.p, model = "within"))
> 
> detect.lindep(model.matrix(mf, model = "within"))
[1] "Suspiscious column number(s): 2, 3"
[1] "Suspiscious column name(s):   fact1, fact2"
> #MM mod_fe <- plm(pform, data = Cigar.p, model = "within")
> mod_fe <- plm(form, data = Cigar.p, model = "within")
> detect.lindep(mod_fe)
[1] "Suspiscious column number(s): 2, 3"
[1] "Suspiscious column name(s):   fact1, fact2"
> 
> # test with NA matrix and empty matrix
> detect.lindep(matrix(NA))                     # NA matrix
[1] "No linear dependent column(s) detected."
> detect.lindep(matrix(NA, nrow = 0, ncol = 0)) # empty matrix
[1] "No linear dependent column(s) detected."
> 
> # linear dependent column(s) are silently dropped in plm estimation, thus this works
> #mod_fe <- plm(pform, data = Cigar.p, model = "within")
> mod_fe <- plm(form, data = Cigar.p, model = "within")
> detect.lindep(model.matrix(mod_fe))
[1] "Suspiscious column number(s): 2, 3"
[1] "Suspiscious column name(s):   fact1, fact2"
> 
> # tests with suppressed printing
> detect.lindep(matrix(NA), suppressPrint = TRUE)                     # NA matrix
NULL
> detect.lindep(matrix(NA, nrow = 0, ncol = 0), suppressPrint = TRUE) # empty matrix
NULL
> #MM detect.lindep(model.matrix(pform, data = Cigar.p, model = "pooling"), suppressPrint = TRUE)
> #MM detect.lindep(model.matrix(pform, data = Cigar.p, model = "within"), suppressPrint = TRUE)
> detect.lindep(model.matrix(mf, model = "pooling"), suppressPrint = TRUE)
NULL
> detect.lindep(model.matrix(mf, model = "within"), suppressPrint = TRUE)
fact1 fact2 
    2     3 
> detect.lindep(model.matrix(mod_fe), suppressPrint = TRUE)
fact1 fact2 
    2     3 
> 
> # test for (p)data.frame interface
> df <- as.data.frame(model.matrix(mod_fe))
> detect.lindep(df)
[1] "Suspiscious column number(s): 2, 3"
[1] "Suspiscious column name(s):   fact1, fact2"
> detect.lindep(Cigar)
[1] "No linear dependent column(s) detected."
> Cigar.p$price2 <- 2*Cigar.p$price
> detect.lindep(Cigar.p)
[1] "Suspiscious column number(s): 3, 12"
[1] "Suspiscious column name(s):   price, price2"
> detect.lindep(Cigar.p, suppressPrint = TRUE)
[1] "Suspiscious column number(s): 3, 12"
[1] "Suspiscious column name(s):   price, price2"
> 
> 
> 
> ######## alias.plm, alias.pFormula ######
> #MM lmmod1 <- lm(pform, data = Cigar.p)
> lmmod1 <- lm(form, data = Cigar.p)
> 
> alias(lmmod1)
Model :
price ~ 0 + cpi + fact1 + fact2

> 
> #MM plm_fe <- plm(pform, data = Cigar.p, model = "within")
> plm_fe <- plm(form, data = Cigar.p, model = "within")
> #YC plm_re <- plm(pform, data = Cigar.p, model = "random")                                  # The between model is very special, as there is no interept and cpi is constant
> #MM plm_re_wal <- plm(pform, data = Cigar.p, model = "random", random.method = "walhus")
> #MM plm_fd <- plm(pform, data = Cigar.p, model = "fd")
> #MM plm_pool <- plm(pform, data = Cigar.p, model = "pooling")
> plm_re_wal <- plm(form, data = Cigar.p, model = "random", random.method = "walhus")
> plm_fd <- plm(form, data = Cigar.p, model = "fd")
> plm_pool <- plm(form, data = Cigar.p, model = "pooling")
> 
> names(plm_fe$model)
[1] "price" "cpi"   "fact1" "fact2"
> summary(plm_fe)
Oneway (individual) effect Within Model

Call:
plm(formula = form, data = Cigar.p, model = "within")

Balanced Panel: n = 46, T = 30, N = 1380

Residuals:
     Min.   1st Qu.    Median   3rd Qu.      Max. 
-29.59679  -6.48806   0.90744   6.68253  56.79803 

Coefficients: (1 dropped because of singularities)
       Estimate Std. Error  t-value Pr(>|t|)    
cpi   1.0896210  0.0091879 118.5928  < 2e-16 ***
fact1 1.8678965  0.6710140   2.7837  0.00545 ** 
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Total Sum of Squares:    2397500
Residual Sum of Squares: 206370
R-Squared:      0.91392
Adj. R-Squared: 0.91089
F-statistic: 7071.25 on 2 and 1332 DF, p-value: < 2.22e-16
> alias(plm_fe)
Model :
[1] "price ~ 0 + cpi + fact1 + fact2"

Complete :
      cpi fact1
fact2  0  -1   

> #YC alias(plm_re)
> alias(plm_re_wal)
Model :
[1] "price ~ 0 + cpi + fact1 + fact2"

> alias(plm_fd)
Model :
[1] "price ~ 0 + cpi + fact1 + fact2"

Complete :
      cpi fact1
fact2  0  -1   

> alias(plm_pool)
Model :
[1] "price ~ 0 + cpi + fact1 + fact2"

> 
> # Test variation of parameters
> # alias.lm(object, complete = TRUE, partial = FALSE, partial.pattern = FALSE, ...)
> alias(plm_fe, complete = FALSE)
Model :
[1] "price ~ 0 + cpi + fact1 + fact2"

Complete :
      cpi fact1
fact2  0  -1   

> alias(plm_fe, partial = TRUE)
Model :
[1] "price ~ 0 + cpi + fact1 + fact2"

Complete :
      cpi fact1
fact2  0  -1   

Warning message:
In alias.plm(plm_fe, partial = TRUE) :
  alias.plm/alias.pFormula: arg partial = "TRUE" not supported, changed to FALSE
> alias(plm_fe, partial.pattern = TRUE)
Model :
[1] "price ~ 0 + cpi + fact1 + fact2"

Complete :
      cpi fact1
fact2  0  -1   

Warning message:
In alias.plm(plm_fe, partial.pattern = TRUE) :
  alias.plm/alias.pFormula: arg partial.pattern = "TRUE" not supported, changed to FALSE
> 
> #MM alias(pform, Cigar.p, model = "within")
> alias(mf, model = "within")
Model :
[1] "price ~ 0 + cpi + fact1 + fact2"

Complete :
      cpi fact1
fact2  0  -1   

> #YC alias(pform, Cigar.p, model = "random")
> #MM alias(pform, Cigar.p, model = "random", random.method = "walhus")
> alias(mf, model = "random", random.method = "walhus")
Model :
[1] "price ~ 0 + cpi + fact1 + fact2"

> # alias(pform, Cigar.p, model = "within", inst.method = "bvk") # should give informative error
> 
> #MM alias(pform, Cigar.p, model = "fd")
> #MM alias(pform, Cigar.p, model = "pooling")
> 
> alias(mf, model = "fd")
Model :
[1] "price ~ 0 + cpi + fact1 + fact2"

Complete :
      cpi fact1
fact2  0  -1   

> alias(mf, model = "pooling")
Model :
[1] "price ~ 0 + cpi + fact1 + fact2"

> 
> #MM alias(pform, Cigar.p, model = "within", complete = FALSE)
> #MM alias(pform, Cigar.p, model = "within", partial = TRUE)
> #MM alias(pform, Cigar.p, model = "within", partial.pattern = TRUE)
> 
> alias(mf, model = "within", complete = FALSE)
Model :
[1] "price ~ 0 + cpi + fact1 + fact2"

Complete :
      cpi fact1
fact2  0  -1   

> alias(mf, model = "within", partial = TRUE)
Model :
[1] "price ~ 0 + cpi + fact1 + fact2"

Complete :
      cpi fact1
fact2  0  -1   

Warning message:
In alias.plm(plmobj, ...) :
  alias.plm/alias.pFormula: arg partial = "TRUE" not supported, changed to FALSE
> alias(mf, model = "within", partial.pattern = TRUE)
Model :
[1] "price ~ 0 + cpi + fact1 + fact2"

Complete :
      cpi fact1
fact2  0  -1   

Warning message:
In alias.plm(plmobj, ...) :
  alias.plm/alias.pFormula: arg partial.pattern = "TRUE" not supported, changed to FALSE
> 
> 
> # Tests for names of plm_object$aliased
> if (!isTRUE(all.equal(names(mod_fe$aliased), colnames(model.matrix(mod_fe)))))
+   stop("Names not correct (not like colnames of model.matrix: ", paste0(names(mod_fe$aliased), collapse = ", "))
> 
> proc.time()
   user  system elapsed 
  1.167   0.067   1.219 
